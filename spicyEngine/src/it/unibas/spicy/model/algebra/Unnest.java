/*
    Copyright (C) 2007-2011  Database Group - Universita' della Basilicata
    Giansalvatore Mecca - giansalvatore.mecca@unibas.it
    Salvatore Raunich - salrau@gmail.com

    This file is part of ++Spicy - a Schema Mapping and Data Exchange Tool
    
    ++Spicy is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    any later version.

    ++Spicy is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ++Spicy.  If not, see <http://www.gnu.org/licenses/>.
 */
 
package it.unibas.spicy.model.algebra;

import it.unibas.spicy.utility.SpicyEngineConstants;
import it.unibas.spicy.model.algebra.operators.IAlgebraTreeVisitor;
import it.unibas.spicy.model.datasource.DataSource;
import it.unibas.spicy.model.datasource.INode;
import it.unibas.spicy.model.datasource.nodes.AttributeNode;
import it.unibas.spicy.model.datasource.nodes.LeafNode;
import it.unibas.spicy.model.datasource.nodes.MetadataNode;
import it.unibas.spicy.model.datasource.nodes.SequenceNode;
import it.unibas.spicy.model.datasource.nodes.SetNode;
import it.unibas.spicy.model.datasource.nodes.TupleNode;
import it.unibas.spicy.model.datasource.nodes.UnionNode;
import it.unibas.spicy.model.datasource.values.NullValueFactory;
import it.unibas.spicy.model.datasource.operators.FindNode;
import it.unibas.spicy.model.datasource.operators.INodeVisitor;
import it.unibas.spicy.model.mapping.proxies.ConstantDataSourceProxy;
import it.unibas.spicy.model.mapping.IDataSourceProxy;
import it.unibas.spicy.model.datasource.values.IOIDGeneratorStrategy;
import it.unibas.spicy.model.datasource.values.IntegerOIDGenerator;
import it.unibas.spicy.model.paths.PathExpression;
import it.unibas.spicy.model.paths.SetAlias;
import it.unibas.spicy.model.paths.VariablePathExpression;
import it.unibas.spicy.model.paths.operators.FindPathsInVariable;
import it.unibas.spicy.model.paths.operators.GeneratePathExpression;
import it.unibas.spicy.utility.SpicyEngineUtility;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class Unnest extends LeafOperator {

    private static Log logger = LogFactory.getLog(Unnest.class);
    private SetAlias variable;

    public Unnest(SetAlias variable) {
        this.variable = variable;
    }

    public void removeChild(IAlgebraOperator child) {
        throw new UnsupportedOperationException("Operation not supported.");
    }

    public SetAlias getVariable() {
        return variable;
    }

    public String getName() {
        return "unnest";
    }

    public void accept(IAlgebraTreeVisitor visitor) {
        visitor.visitUnnest(this);
    }

    public IDataSourceProxy execute(IDataSourceProxy dataSource) {
        if (this.result != null) {
            if (logger.isDebugEnabled()) logger.debug("Unnest " + printIds() + " - Returning cached result...");
            return result;
        }
        if (logger.isDebugEnabled()) logger.debug("Starting unnest " + printIds());
        if (logger.isDebugEnabled()) logger.debug("of variable:" + variable + " on data source\n" + dataSource.toInstanceString());
        result = new UnnestOperator(variable).execute(dataSource);
        if (logger.isDebugEnabled()) logger.debug("Final result of unnest:\n" + result.toInstanceString());
        return result;
    }
}

class UnnestOperator {

    private static Log logger = LogFactory.getLog(UnnestOperator.class);
    
    private SetAlias variable;
    private FindNode nodeFinder = new FindNode();
    private FindPathsInVariable pathFinderInVariable = new FindPathsInVariable();

    UnnestOperator(SetAlias variable) {
        this.variable = variable;
    }

    IDataSourceProxy execute(IDataSourceProxy dataSource) {
        if (logger.isDebugEnabled()) logger.trace("Unnesting variable: " + variable);
        INode schema = generateSchema(dataSource);
        IDataSourceProxy result = new ConstantDataSourceProxy(new DataSource(SpicyEngineConstants.TYPE_ALGEBRA_RESULT, schema));
        if (dataSource.getInstances().size() > 0) {
            for (INode instance : dataSource.getInstances()) {
                INode unnestedInstance = generateInstance(instance, dataSource);
                if (logger.isDebugEnabled()) logger.trace("Instance generated by visitor: " + unnestedInstance.toShortString());
                result.addInstance(unnestedInstance);
                if (logger.isDebugEnabled()) logger.trace("Current result: " + result.toInstanceString());
            }
        }
        return result;
    }

    private INode generateSchema(IDataSourceProxy dataSource) {
        if (logger.isTraceEnabled()) logger.trace("Generating schema");
        SetNode setNode = new SetNode(SpicyEngineUtility.generateSetNodeLabel());
        setNode.setRoot(true);
        setNode.setRequired(true);
        setNode.setNotNull(true);
        TupleNode tupleNode = new TupleNode(SpicyEngineUtility.generateTupleNodeLabel());
        tupleNode.setRequired(true);
        tupleNode.setNotNull(true);
        setNode.addChild(tupleNode);
        List<VariablePathExpression> attributePaths = pathFinderInVariable.findAttributePaths(variable, dataSource.getIntermediateSchema());
        for (VariablePathExpression relativePath : attributePaths) {
            if (logger.isTraceEnabled()) logger.trace("Examining path: " + relativePath);
            PathExpression absolutePath = relativePath.getAbsolutePath();
            if (logger.isTraceEnabled()) logger.trace("Absolute path: " + absolutePath);
            AttributeNode attributeNode = (AttributeNode) nodeFinder.findNodeInSchema(absolutePath, dataSource).clone();
            attributeNode.setNotNull(false);
            attributeNode.setLabel(relativePath.toString());
            tupleNode.addChild(attributeNode);
        }
        return setNode;
    }

    private INode generateInstance(INode instanceRoot, IDataSourceProxy dataSource) {
        List<VariablePathExpression> attributePaths = pathFinderInVariable.findAttributePaths(variable, dataSource.getIntermediateSchema());
        UnnestVariableVisitor visitor = new UnnestVariableVisitor(variable, attributePaths, dataSource);
        instanceRoot.accept(visitor);
        return visitor.getResult();
    }
}

class UnnestVariableVisitor implements INodeVisitor {

    private static Log logger = LogFactory.getLog(UnnestVariableVisitor.class);
    
    private IDataSourceProxy dataSource;
    private List<String> setNodeLabels;
    private TupleBuffer currentUnnestedTuple;
    private List<TupleBuffer> unnestedTuples;
    private List<VariablePathExpression> attributePaths;

    private IOIDGeneratorStrategy oidGenerator = new IntegerOIDGenerator();
    private PathTranslator pathTranslator = new PathTranslator();

    UnnestVariableVisitor(SetAlias variable, List<VariablePathExpression> attributePaths, IDataSourceProxy dataSource) {
        if (logger.isDebugEnabled()) logger.trace("Visiting data source to unnest variable: " + variable + " - Attribute paths: " + attributePaths);
        this.dataSource = dataSource;
        this.setNodeLabels = generateSetNodeLabels(variable);
        this.currentUnnestedTuple = new TupleBuffer();
        this.unnestedTuples = new ArrayList<TupleBuffer>();
        this.unnestedTuples.add(currentUnnestedTuple);
        this.attributePaths = attributePaths;
        this.pathTranslator = initializePathTranslator(attributePaths);
    }

    private List<String> generateSetNodeLabels(SetAlias variable) {
        List<String> result = new ArrayList<String>();
        List<SetAlias> variableGenerators = variable.getGenerators();
        for (SetAlias generator : variableGenerators) {
            result.add(generator.getBindingPathExpression().getLastNode(dataSource.getIntermediateSchema()).getLabel());
        }
        return result;
    }

    private PathTranslator initializePathTranslator(List<VariablePathExpression> attributePaths) {
        for (VariablePathExpression relativePath : attributePaths) {
            PathExpression absolutePath = relativePath.getAbsolutePath();
            pathTranslator.addPathPair(absolutePath, relativePath);
        }
        return pathTranslator;
    }

    public void visitSetNode(SetNode setNode) {
        if (setNodeLabels.contains(setNode.getLabel())) {
            if (logger.isDebugEnabled()) logger.trace("Visiting set node: " + setNode.getLabel());
            TupleBuffer currentTupleCopy = currentUnnestedTuple.clone();
            if (logger.isDebugEnabled()) logger.trace("Current tuple:\n" + currentTupleCopy);
            if (setNode.getChildren().size() != 0) {
                this.unnestedTuples.remove(currentUnnestedTuple);
            }
            for (INode tupleNode : setNode.getChildren()) {
                this.currentUnnestedTuple = currentTupleCopy.clone();
                this.unnestedTuples.add(currentUnnestedTuple);
                this.currentUnnestedTuple.addTupleNode(tupleNode);
                if (logger.isDebugEnabled()) logger.trace("Set node: " + setNode.getLabel() + " - Resetting tuple:\n" + currentUnnestedTuple);
                tupleNode.accept(this);
            }
        }
    }

    public void visitTupleNode(TupleNode tupleNode) {
        visitChildren(tupleNode);
    }

    public void visitSequenceNode(SequenceNode sequenceNode) {
        visitChildren(sequenceNode);
    }

    public void visitUnionNode(UnionNode unionNode) {
        visitChildren(unionNode);
    }

    private void visitChildren(INode node) {
        for (INode child : node.getChildren()) {
            if (!(child instanceof SetNode)) {
                child.accept(this);
            }
        }
        for (INode child : node.getChildren()) {
            if (child instanceof SetNode) {
                child.accept(this);
            }
        }
    }

    public void visitAttributeNode(AttributeNode attributeNode) {
        if (logger.isDebugEnabled()) logger.trace("Visiting attribute: " + attributeNode.getLabel());
        GeneratePathExpression pathGenerator = new GeneratePathExpression();
        PathExpression absolutePath = pathGenerator.generatePathFromRoot(attributeNode);
        if (logger.isTraceEnabled()) logger.trace("Attribute path: " + absolutePath);
        VariablePathExpression relativePath = pathTranslator.findRelativePath(absolutePath);
        if (relativePath != null) {
            if (logger.isDebugEnabled()) logger.trace("Attribute must be added to current tuple");
            addAttributeToTuple(attributeNode, relativePath);
        }
    }

    public void visitMetadataNode(MetadataNode metadataNode) {
        visitAttributeNode(metadataNode);
    }

    public void visitLeafNode(LeafNode leafNode) {
        return;
    }

    private void addAttributeToTuple(AttributeNode attributeNode, VariablePathExpression attributePath) {
        AttributeNode newAttributeNode = (AttributeNode) SpicyEngineUtility.createNode("AttributeNode", attributeNode.getLabel(), oidGenerator.getNextOID());
        INode leafNode = attributeNode.getChild(0);
        INode newLeaf = SpicyEngineUtility.createNode("LeafNode", leafNode.getLabel(), leafNode.getValue());
        newAttributeNode.addChild(newLeaf);
        currentUnnestedTuple.putAttribute(attributePath, newAttributeNode);
        if (logger.isDebugEnabled()) logger.trace("Attribute added to current tuple:\n" + currentUnnestedTuple);
    }

    public SetNode getResult() {
        SetNode result = new SetNode(SpicyEngineUtility.generateSetNodeLabel(), oidGenerator.getNextOID());
        result.setRoot(true);
        int numberOfSourceTuples = findNumberOfSourceTuples(unnestedTuples);
        for (TupleBuffer unnestedTuple : unnestedTuples) {
            if (unnestedTuple.size() == 0 || unnestedTuple.getSourceTuples().size() < numberOfSourceTuples) {
                continue;
            }
            TupleNode viewTuple = new TupleNode(SpicyEngineUtility.generateTupleNodeLabel(), oidGenerator.getNextOID());
            for (VariablePathExpression attributePath : attributePaths) {
                AttributeNode attributeNode = unnestedTuple.getAttributeNode(attributePath);
                if (attributeNode == null) {
                    attributeNode = generateNullAttribute(attributePath);
                }
                attributeNode.setLabel(attributePath.toString());
                viewTuple.addChild(attributeNode);
            }
            viewTuple.addProvenanceList(unnestedTuple.getProvenance());
            result.addChild(viewTuple);
            if (logger.isDebugEnabled()) logger.trace("Tuple to add: " + viewTuple);
            if (logger.isDebugEnabled()) logger.trace("Current view instance: " + result.toShortString());
        }
        return result;
    }

    private int findNumberOfSourceTuples(List<TupleBuffer> unnestedTuples) {
        int sourceTuples = 0;
        for (TupleBuffer unnestedTuple : unnestedTuples) {
            if (unnestedTuple.getSourceTuples().size() > sourceTuples) {
                sourceTuples = unnestedTuple.getSourceTuples().size();
            }
        }
        return sourceTuples;
    }

    private AttributeNode generateNullAttribute(VariablePathExpression attributePath) {
        PathExpression absolutePath = pathTranslator.findAbsolutePath(attributePath);
        FindNode nodeFinder = new FindNode();
        INode attributeInSchema = nodeFinder.findNodeInSchema(absolutePath, dataSource);
        INode leafNodeInSchema = attributeInSchema.getChild(0);
        AttributeNode attributeNode = new AttributeNode(attributePath.toString(), oidGenerator.getNextOID());
        LeafNode nullValue = new LeafNode(leafNodeInSchema.getLabel(), NullValueFactory.getNullValue());
        attributeNode.addChild(nullValue);
        return attributeNode;
    }
}

class TupleBuffer implements Cloneable {

    private Map<VariablePathExpression, AttributeNode> attributeNodes = new HashMap<VariablePathExpression, AttributeNode>();
    private List<INode> tupleNodes = new ArrayList<INode>();

    void putAttribute(VariablePathExpression pathExpression, AttributeNode attributeNode) {
        attributeNodes.put(pathExpression, attributeNode);
    }

    AttributeNode getAttributeNode(VariablePathExpression pathExpression) {
        return attributeNodes.get(pathExpression);
    }

    void addTupleNode(INode tupleNode) {
        if (!tupleNodes.contains(tupleNode)) {
            this.tupleNodes.add(tupleNode);
        }
    }

    List<INode> getSourceTuples() {
        return tupleNodes;
    }

    List<String> getProvenance() {
        List<String> result = new ArrayList<String>();
        for (INode sourceTuple : tupleNodes) {
            if (sourceTuple instanceof TupleNode) {
                for (String tupleId : ((TupleNode) sourceTuple).getProvenance()) {
                    if (!result.contains(tupleId)) {
                        result.add(tupleId);
                    }
                }
            }
        }
        return result;
    }

    int size() {
        return attributeNodes.values().size();
    }

    void clear() {
        attributeNodes.clear();
    }

    public TupleBuffer clone() {
        TupleBuffer clone = new TupleBuffer();
        clone.attributeNodes = new HashMap<VariablePathExpression, AttributeNode>(attributeNodes);
        clone.tupleNodes = new ArrayList<INode>(tupleNodes);
        return clone;
    }

    public String toString() {
        String result = "------------ TUPLE BUFFER ------------------\n";
        for (PathExpression pathExpression : attributeNodes.keySet()) {
            result += pathExpression + ": " + attributeNodes.get(pathExpression).getChild(0).getValue() + "\n";
        }
        result += "---------------------------------------------";
        return result;
    }
}

class PathTranslator {

    private Map<PathExpression, VariablePathExpression> pathMap = new HashMap<PathExpression, VariablePathExpression>();

    void addPathPair(PathExpression absolutePath, VariablePathExpression relativePath) {
        pathMap.put(absolutePath, relativePath);
    }

    Collection<VariablePathExpression> getAttributePaths() {
        return pathMap.values();
    }

    int size() {
        return pathMap.values().size();
    }

    VariablePathExpression findRelativePath(PathExpression absolutePath) {
        for (PathExpression pathExpression : pathMap.keySet()) {
            if (pathExpression.equals(absolutePath)) {
                return pathMap.get(pathExpression);
            }
        }
        return null;
    }

    PathExpression findAbsolutePath(VariablePathExpression relativePath) {
        for (PathExpression absolutePath : pathMap.keySet()) {
            VariablePathExpression candidateRelativePath = pathMap.get(absolutePath);
            if (candidateRelativePath.equals(relativePath)) {
                return absolutePath;
            }
        }
        return null;
    }
}
