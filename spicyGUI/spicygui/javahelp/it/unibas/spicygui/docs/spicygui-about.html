<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtHgold 4.00">
 <style type="text/css"> div.p { margin-top: 7pt;}</style>
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>

 
<title> ++Spicy Mapping System</title>
 
<h1 align="center">++Spicy Mapping System </h1>

<div class="p"><!----></div>

<h3 align="center">
Dipartimento di Matematica e Informatica<br />
Universit&#224; della Basilicata - Potenza, Italy<br />
<tt>http://www.db.unibas.it/projects/spicy</tt>
 </h3>

<div class="p"><!----></div>

<h1>Contents </h1><a href="#tth_sEc1"
>1&nbsp; Overview</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1"
>1.1&nbsp; Description</a><br />
<a href="#tth_sEc2"
>2&nbsp; Graphical User Interface</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.1"
>2.1&nbsp; Main Constructs</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.2"
>2.2&nbsp; Loading Tgds from Parser</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.3"
>2.3&nbsp; Spicy Matching Module</a><br />
<a href="#tth_sEc3"
>3&nbsp; Main Functionalities</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.1"
>3.1&nbsp; Executable Scripts</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2"
>3.2&nbsp; Chase Engine</a><br />
<a href="#tth_sEc4"
>4&nbsp; Advanced Features</a><br />



<div class="p"><!----></div>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Overview</h2> <a name="sec:overview">
</a>
This document describes  ++S<font size="-2">PICY</font>, an open-source <em>schema mapping system</em> developed at the Universit&#224; della Basilicata by the group lead by Prof. Giansalvatore Mecca.  ++S<font size="-2">PICY</font> supports data management problems where there is the need to exchange, transform and integrate data. In particular, given a visual specification of  the desired transformation between a source schema and a target one,  ++S<font size="-2">PICY</font> generates the corresponding schema mappings (expressed as source to target dependencies), and then the executable scripts needed to perform the translation with a data exchange semantics.

<div class="p"><!----></div>
     <h3><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;Description</h3>

<div class="p"><!----></div>
The  ++S<font size="-2">PICY</font> system is an evolution of the original Spicy&nbsp;[<a href="#Bonifati2008" name="CITEBonifati2008">2</a>,<a href="#Bonifati08b" name="CITEBonifati08b">1</a>] and +Spicy&nbsp;[<a href="#Mecca2009b" name="CITEMecca2009b">7</a>] systems. It has been developed in Java using the NetBeans Platform as a basis for the graphical user interface. The system architecture is shown in Figure&nbsp;<a href="#fig:architecture">1</a>. 

<div class="p"><!----></div>

<div class="p"><!----></div>
<a name="tth_fIg1">
</a> 
<center><img src="images/architecture.png" alt="images/architecture.png" />


<center>Figure 1: <font size="-1">Architecture of ++Spicy</font></center> <a name="fig:architecture">
</a>
</center>


<div class="p"><!----></div>
In a typical usage scenario, a user provides to the  ++S<font size="-2">PICY</font>&nbsp;system a <b>mapping specification</b> using the GUI; in doing this, besides specifying the source and target schema, users can rely on the primitives offered by the system (which we describe in the following). 
The mapping specification is then handled by the <b>mapping generation</b> module, which generates the tgds. As an alternative, a <b>parser</b> is available to load a set of pre-defined tgds and egds from text files. The parser generates a scenario from the file and shows it to the user so that she can visually inspect and possibly modify it in the GUI.

<div class="p"><!----></div>
At this point, the user has a set of tgds, either generated internally or pre-defined and loaded by the parser. Before moving to the actual query generation phase, the tgds are rewritten by the <b>rewriting engine</b> in order to ensure that optimal (i.e., core) solutions are generated.  

<div class="p"><!----></div>
Based on these rewritten tgds, an executable query either in SQL or in XQuery can be generated by the <b>query generation engine</b>. The system integrates interfaces to various popular SQL and XQuery engines (like PostgreSQL and Saxon), so that the final query can be executed against one or more source instances and results can be inspected using the GUI. To simplify the debugging of the mapping scenario and to reduce dependencies wrt external systems,  ++S<font size="-2">PICY</font> also incorporates an <b>internal chase engine</b> to execute the source to target tgds and generate solutions internally. This latter execution is more immediate than sending a query to an external engine, and greatly helps users during their work sessions.

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;Graphical User Interface</h2> <a name="sec:gui">
</a>

<div class="p"><!----></div>

<div class="p"><!----></div>
<a name="tth_fIg2">
</a> 
<center><img src="images/gui.png" alt="images/gui.png" />


<center>Figure 2: <font size="-1">Screenshot of ++Spicy GUI</font></center> <a name="fig:gui">
</a>
</center>


<div class="p"><!----></div>
Figure&nbsp;<a href="#fig:gui">2</a> depicts the main working screen for the system. 

<div class="p"><!----></div>
The button bar at the top contains three sections. The section on the left has the basic operations to create, load, save mapping scenarios. The central part controls view options to show/hide schema constraints, join conditions, and functional dependencies. The right section gives quick access to the most important operation: generate transformations and translate instances. Rolling over a button explains its operation and the respective keyboard shortcut.

<div class="p"><!----></div>
On the left side, the <i>Scenarios</i> panel exposes all the objects involved in the selected working scenario (schemas, instances) and the possible views over the artifacts handled by the system: transformations expressed in logical form, executable scripts, detailed log of the tgds generated by the mapping generation module and their rewriting.

<div class="p"><!----></div>
On the right side, the three panels contain the source schema, the manipulation area (yellow background), and the target schema, respectively. The schemas are represented in a hierarchical view of their structure by using nesting of set, records (followed by their min and max cardinality in the set), and atomic elements (followed by their data type between brackets). Join dependencies between elements are show as grey lines connecting elements, by rolling over the joins it is possible to see if they are mandatory or optional, and if they are bidirectional or not. 

<div class="p"><!----></div>
The tabs over the schemas allow the quick navigation among the opened views for the current scenario.

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Main Constructs</h3> <a name="sec:constructs">
</a>

<div class="p"><!----></div>
There are many constructs that users can apply to define the desired transformation, namely: 

<dl compact="compact">
 <dt><b>1:1 correspondences</b></dt>
	<dd> Express equivalence relationship among atomic elements of the schemas. A correspondence is defined with a drag-and-drop operation: the active (i.e., draggable) area for the source elements is their right part (the datatype area), for the target elements is their left part (the icon);</dd>
 <dt><b>n:1 value correspondences</b></dt>
	<dd> Let the user define complex transformation functions, as for instance: split(Source.Contact.name, ", ", 1). Right click in the manipulation area to create a new function, add the elements that need to be transform (at least one) and then double click to "open" the black box and define the function<a href="#tthFtNtAAB" name="tthFrefAAB"><sup>1</sup></a>;</dd>
 <dt><b>duplicate sets</b></dt>
	<dd>
Let the user duplicate sets in the source and in the target to express complex mappings, for instance, when self-join are involved. Each duplication of a set <i>R</i> corresponds to adding to the data source a new set named <i>R</i>&nbsp;<sup>k</sup>, for some k, that is an exact <em>copy</em> of <i>R</i>. Right click on a set to create a duplicate for it;</dd>
 <dt><b>arbitrary join-conditions in the sources</b></dt>
	<dd> In addition to joins corresponding to foreign key constraints in the schema, users can specify arbitrary join paths, including self-joins. Joins are defined with drag-and-drop operations among elements of the same schema. It is also possible to define more complex join (for instance with two pairs of attributes) by right-clicking near a schema and activating a <em>Multiple Join Session</em>: a pop-up window appears when a new join is defined and following joins are added as long as the window is kept open;</dd>
 <dt><b>filters</b></dt>
	<dd> Allow users to express selection conditions on source sets, like <em>companyName = 'IBM'</em> on the financials table. Right click on a source set to add a selection condition; the condition will be shown next to the set name;</dd>
 <dt><b>constant correspondences</b></dt>
	<dd> Let the user define a constant value over the target instance. Right click in the manipulation area to create a new constant, double click on the box to define it, then add a correspondence to the constant to the target element of interest;</dd>
 <dt><b>functional dependencies</b></dt>
	<dd> Users can define new functional dependencies (i.e., egds) over the attributes.
Right click in the manipulation area to create a new functional dependency icon: elements related with incoming arrows compose the determinant set, while elements pointed from the new icon compose the dependent attributes.</dd>
</dl>

<div class="p"><!----></div>
All the constructs can be erased with a right-click on the construct followed by <em>delete</em>.

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;Loading Tgds from Parser</h3> <a name="sec:parser">
</a>

<div class="p"><!----></div>
An alternative input can be provided to the system by using its mapping parser. Given a set of standard s-t tgds (hand written or generated with another mapping system),  ++S<font size="-2">PICY</font> load them in the GUI, thus providing a graphical representation of the scenario, and is able to rewrite them to obtain optimal solutions as well.

<div class="p"><!----></div>
The input text file is composed of four parts. In the first part it is described where to find the schemas and the source instance. Interestingly, schemas can be generated directly the s-t tgds, which are listed in the second part of the file.
Notice that tgds are required to details the labels of the attributes, followed by the associated variables marked with a dollar sign (e.g., <tt>LivesIn(name: $x41, city: $x42) -&#62; Home(homeName: $x41, homeCity: $x42)</tt>). Every s-t tgd ends with a dot.
In the third part source and target functional dependencies are defined (e.g., <tt>EmpCity : empName -&#62; empCity [pk]</tt>. Finally, the source instance can also be defined in the file and will be automatically load in the system for tests (e.g., <tt>LivesIn(name: &#196;lice", city: "SF")</tt>.

<div class="p"><!----></div>
See the example files "scenario.tgd" in the sample scenarios distributed with the system for more details.

<div class="p"><!----></div>
     <h3><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp;Spicy Matching Module</h3> <a name="sec:spicy">
</a>

<div class="p"><!----></div>

<div class="p"><!----></div>
<a name="tth_fIg3">
</a> 
<center><img src="images/spicy.png" alt="images/spicy.png" />


<center>Figure 3: <font size="-1">Screenshot of the matching module.</font></center> <a name="fig:spicy">
</a>
</center>


<div class="p"><!----></div>
The  ++S<font size="-2">PICY</font> system is an evolution of the original Spicy project&nbsp;[<a href="#Bonifati2008" name="CITEBonifati2008">2</a>,<a href="#Bonifati08b" name="CITEBonifati08b">1</a>], which focused on the automatic matching of elements between schemas. In particular, Spicy introduced a module to match instances of the two schemas (when available) in order to verify not only the correspondences, but also the quality of the schema mapping derived. 

<div class="p"><!----></div>
The Spicy module can be opened from the system toolbar. The Matcher is able to get possible correspondences from the schema, but it needs an input and a target instances to exploit possible alternative schema mappings and rank them. Input and target instances can be loaded with the DataSource menu in the system toolbar.

<div class="p"><!----></div>
Once the transformations are generated with "Find Best Mappings", they are presented to the user ranked with their quality wrt the given instances, so that she can browse the alternatives and pick the most promising mapping. See Figure&nbsp;<a href="#fig:spicy">3</a>. 

<div class="p"><!----></div>

<div class="p"><!----></div>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;Main Functionalities</h2> <a name="sec:functions">
</a>

<div class="p"><!----></div>
Once the mapping scenarios is defined, users can compile it with the system to get the dependencies with the buttons at the top. 

<div class="p"><!----></div>
The <em>Transformations Window</em> exposes all the mapping data, including details over the schemas, their constraints, the original s-t dependencies and their rewritings to enforce target egds and compute optimal solutions.

<div class="p"><!----></div>
     <h3><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;Executable Scripts</h3> <a name="sec:scripts">
</a>

<div class="p"><!----></div>
Once the mapping has been compiled in its logical form, it is possible to generate the corresponding executable scripts (XQuery or SQL) from the Scenarios panel or from the system bar under the <em>Map</em> menu. Scripts generated by the system have been tested on PostgreSQL and Saxon and have been proved to be scalable to large database in most of the scenarios used in our experiments (see&nbsp;[<a href="#Mecca2009" name="CITEMecca2009">5</a>,<a href="#Mecca2011TR" name="CITEMecca2011TR">6</a>,<a href="#Marnette2010" name="CITEMarnette2010">4</a>] for details on execution times).

<div class="p"><!----></div>
As an alternative, it is possible to compute the target instance by using the internal engine that we detail next.

<div class="p"><!----></div>
     <h3><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;Chase Engine</h3> <a name="sec:engine">
</a>

<div class="p"><!----></div>
For user convenience, an internal engine chases the source to target dependencies produced by the rewriting algorithms. The output is the same of the executable scripts and the performance are acceptable for user interaction with instances up to a few thousands tuples.
The input instance can be defined with the DataSource menu in the system toolbar.

<div class="p"><!----></div>

<div class="p"><!----></div>
<a name="tth_fIg4">
</a> 
<center><img src="images/instance.png" alt="images/instance.png" />


<center>Figure 4: <font size="-1">Screenshot of the Instance Window.</font></center> <a name="fig:instance">
</a>
</center>


<div class="p"><!----></div>
The target instance generated by the engine can be observed in the "Instances Window", as shown in Figure&nbsp;<a href="#fig:instance">4</a>. Notice that the system let the user compare the canonical universal solution and the core solution. Moreover, a right click on the right panel reveals some internal technical information that can be useful for debug. For instance, the provenance metadata reports for each record from which s-t tgd it has been created.

<div class="p"><!----></div>

 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Advanced Features</h2> <a name="sec:advanced">
</a>

<div class="p"><!----></div>
The following features highlight why the  ++S<font size="-2">PICY</font> system is a very sophisticated tool. Many of the advanced features can be enabled and disabled from the <em>Configuration</em> panel, which can be accessed with a right click on the Scenarios panel.

<div class="p"><!----></div>
A key contribution of data exchange research is the formalization of the notion of <i>core</i>&nbsp;[<a href="#Fagin2005b" name="CITEFagin2005b">3</a>], which is identified as an "optimal" solution. 
The  ++S<font size="-2">PICY</font> system contains an algorithm to rewrite s-t tgds in order to obtain core solutions with executable scripts. This core computation approach allows a very efficient execution that scales well to large databases. We refer the reader to&nbsp;[<a href="#Mecca2009" name="CITEMecca2009">5</a>,<a href="#Mecca2011TR" name="CITEMecca2011TR">6</a>] for details. By default, the core rewriting is selected in the Configuration panel.

<div class="p"><!----></div>
Core-oriented rewriting algorithms have been extended to handle a very large class of mapping scenarios including target functional dependencies, i.e., target egds in data exchange terminology. This means that  ++S<font size="-2">PICY</font> generates solution that satisfy the target egds by using source to target dependencies only (and therefore, transformations that can be materialized with common executable languages). See&nbsp;[<a href="#Marnette2010" name="CITEMarnette2010">4</a>] for details.
By default, the egd rewriting is deselected in the Configuration panel.

<div class="p"><!----></div>
A crucial technical feature of  ++S<font size="-2">PICY</font> is the management of the Skolem values, i.e., the way the system choose a value for a labeled null in the solution. 
By default, in the internal engine Skolem values are materialized as integers in the solution, this can be changed selecting "Use Skolem Strings"  in the Configuration panel.
In the SQL executable scripts, by default Skolem values are materialized as integers or string in the solution, depending from the target datatype of the element; this can be changed to integers selecting "Skolem Table" in the "Skolem Table Strategy" menu, or it can be changed to string selecting selecting "No Skolem Table". The "Use Hash Text" can improve the execution time performance of the SQL scripts, but does not guarantee that the solution is the core.

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>

<h2>References</h2>

<dl compact="compact">
 <dt><a href="#CITEBonifati08b" name="Bonifati08b">[1]</a></dt><dd>
B.&nbsp;A., M.&nbsp;G., P.&nbsp;A., R.&nbsp;S., and S.&nbsp;G.
 The spicy system: towards a notion of mapping quality.
 In <em>SIGMOD Conference</em>, pages 1289-1294, 2008.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEBonifati2008" name="Bonifati2008">[2]</a></dt><dd>
A.&nbsp;Bonifati, G.&nbsp;Mecca, A.&nbsp;Pappalardo, S.&nbsp;Raunich, and G.&nbsp;Summa.
 Schema Mapping Verification: The Spicy Way.
 In <em>EDBT</em>, pages 85 - 96, 2008.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEFagin2005b" name="Fagin2005b">[3]</a></dt><dd>
R.&nbsp;Fagin, P.&nbsp;Kolaitis, and L.&nbsp;Popa.
 Data Exchange: Getting to the Core.
 <em>ACM TODS</em>, 30(1):174-210, 2005.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEMarnette2010" name="Marnette2010">[4]</a></dt><dd>
B.&nbsp;Marnette, G.&nbsp;Mecca, and P.&nbsp;Papotti.
 Scalable data exchange with functional dependencies.
 <em>PVLDB</em>, 3(1), 2010.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEMecca2009" name="Mecca2009">[5]</a></dt><dd>
G.&nbsp;Mecca, P.&nbsp;Papotti, and S.&nbsp;Raunich.
 Core Schema Mappings.
 In <em>SIGMOD</em>, pages 655-668, 2009.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEMecca2011TR" name="Mecca2011TR">[6]</a></dt><dd>
G.&nbsp;Mecca, P.&nbsp;Papotti, and S.&nbsp;Raunich.
 Core Schema Mappings: Scalable Core Computations in Data Exchange.
 Technical Report Spicy WR-01-2011, Dipartimento di Matematica e
  Informatica - Universit&#224; della Basilicata, 2010.

<div class="p"><!----></div>
</dd>
 <dt><a href="#CITEMecca2009b" name="Mecca2009b">[7]</a></dt><dd>
G.&nbsp;Mecca, P.&nbsp;Papotti, S.&nbsp;Raunich, and M.&nbsp;Buoncristiano.
 Concise and Expressive Mappings with  +S<font size="-2">PICY</font>.
 <em>PVLDB</em>, 2(2):1582-1585, 2009.</dd>
</dl>


<div class="p"><!----></div>

<div class="p"><!----></div>
<hr /><h3>Footnotes:</h3>

<div class="p"><!----></div>
<a name="tthFtNtAAB"></a><a href="#tthFrefAAB"><sup>1</sup></a>For a list of available functions and details refer to the JEP library (version 2.4.1) at <font size="-1"><tt>http://www.singularsys.com/jep</tt></font>
<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>Hgold</a>,
version 4.00.<br />On 24 May 2011, 18:58.</small>
</html>
