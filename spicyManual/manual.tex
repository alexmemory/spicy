\documentclass[12pt]{article}

\usepackage{graphicx}
%\usepackage{tex4ht}

\newcommand{\spicypp}{\textsc{++Spicy}}

\newcommand{\aacc}{\`a}
\newcommand{\tld}{$~$}
\newcommand{\quotes}[1]{``#1''}
\newcommand{\singlequote}[1]{\textit{`{#1}\!'}}
\newcommand{\urlstyle}[1]{{\small \tt #1}}
\newcommand{\parstyle}[1]{\small \bf #1}
\newcommand{\footstyle}[1]{\small #1}
\newcommand{\definition}[1]{{\noindent \small \bf Definition: #1}\tld}
\newcommand{\rel}[1]{{\textit{#1}}}
\newcommand{\relclone}[2]{{\textit{#1}\,^{#2}}}
\newcommand{\attr}[1]{{\textit{#1}}}

\newcommand{\removespace}{\vspace*{-0.35cm}}
\newcommand{\removelargespace}{\vspace*{-0.7cm}}
\newcommand{\spaceintgd}{\hspace*{1.0cm}}
\newcommand{\smallspaceintgd}{\hspace*{0.5cm}}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{++Spicy Mapping System}

\author{
Dipartimento di Matematica e Informatica\\
Universit{\aacc} della Basilicata -- Potenza, Italy\\
{\tt http://www.db.unibas.it/projects/spicy}
}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\setcounter{tocdepth}{3}

\section{Overview} \label{sec:overview}
This document describes {\spicypp}, an open-source {\em schema mapping system} developed at the Universit{\aacc} della Basilicata by the group lead by Prof. Giansalvatore Mecca. {\spicypp} supports data management problems where there is the need to exchange, transform and integrate data. In particular, given a visual specification of  the desired transformation between a source schema and a target one, {\spicypp} generates the corresponding schema mappings (expressed as source to target dependencies), and then the executable scripts needed to perform the translation with a data exchange semantics.

\subsection{Description}

The {\spicypp} system is an evolution of the original Spicy\tld\cite{Bonifati2008,Bonifati08b} and +Spicy\tld\cite{Mecca2009b} systems. It has been developed in Java using the NetBeans Platform as a basis for the graphical user interface. The system architecture is shown in Figure\tld\ref{fig:architecture}. 

\begin{figure}[htb]
\removespace
\begin{center}
\includegraphics[width=0.8\columnwidth]{images/architecture.png}
\removespace
\caption{\small Architecture of ++Spicy} \label{fig:architecture}
\end{center}
\removelargespace
\end{figure}

In a typical usage scenario, a user provides to the \spicypp\ system a {\bf mapping specification} using the GUI; in doing this, besides specifying the source and target schema, users can rely on the primitives offered by the system (which we describe in the following). 
The mapping specification is then handled by the {\bf mapping generation} module, which generates the tgds. As an alternative, a {\bf parser} is available to load a set of pre-defined tgds and egds from text files. The parser generates a scenario from the file and shows it to the user so that she can visually inspect and possibly modify it in the GUI.

At this point, the user has a set of tgds, either generated internally or pre-defined and loaded by the parser. Before moving to the actual query generation phase, the tgds are rewritten by the {\bf rewriting engine} in order to ensure that optimal (i.e., core) solutions are generated.  

Based on these rewritten tgds, an executable query either in SQL or in XQuery can be generated by the {\bf query generation engine}. The system integrates interfaces to various popular SQL and XQuery engines (like PostgreSQL and Saxon), so that the final query can be executed against one or more source instances and results can be inspected using the GUI. To simplify the debugging of the mapping scenario and to reduce dependencies wrt external systems, {\spicypp} also incorporates an {\bf internal chase engine} to execute the source to target tgds and generate solutions internally. This latter execution is more immediate than sending a query to an external engine, and greatly helps users during their work sessions.

%\subsection{Terminology}

%\begin{description}
%\item[Correspondence] the arrow between atomic elements in the GUI. 
%\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Graphical User Interface} \label{sec:gui}

\begin{figure}[htb]
\removespace
\begin{center}
\includegraphics[width=\columnwidth]{images/gui.png}
\removespace
\caption{\small Screenshot of ++Spicy GUI} \label{fig:gui}
\end{center}
\removelargespace
\end{figure}

Figure\tld\ref{fig:gui} depicts the main working screen for the system. 

The button bar at the top contains three sections. The section on the left has the basic operations to create, load, save mapping scenarios. The central part controls view options to show/hide schema constraints, join conditions, and functional dependencies. The right section gives quick access to the most important operation: generate transformations and translate instances. Rolling over a button explains its operation and the respective keyboard shortcut.

On the left side, the {\it Scenarios} panel exposes all the objects involved in the selected working scenario (schemas, instances) and the possible views over the artifacts handled by the system: transformations expressed in logical form, executable scripts, detailed log of the tgds generated by the mapping generation module and their rewriting.

On the right side, the three panels contain the source schema, the manipulation area (yellow background), and the target schema, respectively. The schemas are represented in a hierarchical view of their structure by using nesting of set, records (followed by their min and max cardinality in the set), and atomic elements (followed by their data type between brackets). Join dependencies between elements are show as grey lines connecting elements, by rolling over the joins it is possible to see if they are mandatory or optional, and if they are bidirectional or not. 

The tabs over the schemas allow the quick navigation among the opened views for the current scenario.

\subsection{Main Constructs} \label{sec:constructs}

There are many constructs that users can apply to define the desired transformation, namely: 
\begin{description}
\item [1:1 correspondences] Express equivalence relationship among atomic elements of the schemas. A correspondence is defined with a drag-and-drop operation: the active (i.e., draggable) area for the source elements is their right part (the datatype area), for the target elements is their left part (the icon);  

\item [n:1 value correspondences] Let the user define complex transformation functions, as for instance: {split(Source.Contact.name, ", ", 1)}. Right click in the manipulation area to create a new function, add the elements that need to be transform (at least one) and then double click to \quotes{open} the black box and define the function\footnote{For a list of available functions and details refer to the JEP library (version 2.4.1) at \urlstyle{http://www.singularsys.com/jep}};  

\item [duplicate sets]
Let the user duplicate sets in the source and in the target to express complex mappings, for instance, when self-join are involved. Each duplication of a set \rel{R} corresponds to adding to the data source a new set named $\relclone{R}{k}$, for some $k$, that is an exact \emph{copy} of \rel{R}. Right click on a set to create a duplicate for it;
 
\item [arbitrary join-conditions in the sources] In addition to joins corresponding to foreign key constraints in the schema, users can specify arbitrary join paths, including self-joins. Joins are defined with drag-and-drop operations among elements of the same schema. It is also possible to define more complex join (for instance with two pairs of attributes) by right-clicking near a schema and activating a {\em Multiple Join Session}: a pop-up window appears when a new join is defined and following joins are added as long as the window is kept open;

\item [filters] Allow users to express selection conditions on source sets, like \emph{companyName = 'IBM'} on the financials table. Right click on a source set to add a selection condition; the condition will be shown next to the set name;

\item [constant correspondences] Let the user define a constant value over the target instance. Right click in the manipulation area to create a new constant, double click on the box to define it, then add a correspondence to the constant to the target element of interest;

\item [functional dependencies] Users can define new functional dependencies (i.e., egds) over the attributes.
Right click in the manipulation area to create a new functional dependency icon: elements related with incoming arrows compose the determinant set, while elements pointed from the new icon compose the dependent attributes. 

\end{description}

All the constructs can be erased with a right-click on the construct followed by {\em delete}.

\subsection{Loading Tgds from Parser} \label{sec:parser}

An alternative input can be provided to the system by using its mapping parser. Given a set of standard s-t tgds (hand written or generated with another mapping system), {\spicypp} load them in the GUI, thus providing a graphical representation of the scenario, and is able to rewrite them to obtain optimal solutions as well.
 
The input text file is composed of four parts. In the first part it is described where to find the schemas and the source instance. Interestingly, schemas can be generated directly the s-t tgds, which are listed in the second part of the file.
Notice that tgds are required to details the labels of the attributes, followed by the associated variables marked with a dollar sign (e.g., {\tt LivesIn(name: \$x41, city: \$x42) -> Home(homeName: \$x41, homeCity: \$x42)}). Every s-t tgd ends with a dot.
In the third part source and target functional dependencies are defined (e.g., {\tt EmpCity : empName -> empCity [pk]}. Finally, the source instance can also be defined in the file and will be automatically load in the system for tests (e.g., {\tt LivesIn(name: "Alice", city: "SF")}.

See the example files \quotes{scenario.tgd} in the sample scenarios distributed with the system for more details.

\subsection{Spicy Matching Module} \label{sec:spicy}

\begin{figure}[htb]
\removespace
\begin{center}
\includegraphics[width=\columnwidth]{images/spicy.png}
\removespace
\caption{\small Screenshot of the matching module.} \label{fig:spicy}
\end{center}
\removelargespace
\end{figure}

The {\spicypp} system is an evolution of the original Spicy project\tld\cite{Bonifati2008,Bonifati08b}, which focused on the automatic matching of elements between schemas. In particular, Spicy introduced a module to match instances of the two schemas (when available) in order to verify not only the correspondences, but also the quality of the schema mapping derived. 

The Spicy module can be opened from the system toolbar. The Matcher is able to get possible correspondences from the schema, but it needs an input and a target instances to exploit possible alternative schema mappings and rank them. Input and target instances can be loaded with the DataSource menu in the system toolbar.

Once the transformations are generated with \quotes{Find Best Mappings}, they are presented to the user ranked with their quality wrt the given instances, so that she can browse the alternatives and pick the most promising mapping. See Figure\tld\ref{fig:spicy}. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Main Functionalities} \label{sec:functions}

Once the mapping scenarios is defined, users can compile it with the system to get the dependencies with the buttons at the top. 

The {\em Transformations Window} exposes all the mapping data, including details over the schemas, their constraints, the original s-t dependencies and their rewritings to enforce target egds and compute optimal solutions.

\subsection{Executable Scripts} \label{sec:scripts}

Once the mapping has been compiled in its logical form, it is possible to generate the corresponding executable scripts (XQuery or SQL) from the Scenarios panel or from the system bar under the {\em Map} menu. Scripts generated by the system have been tested on PostgreSQL and Saxon and have been proved to be scalable to large database in most of the scenarios used in our experiments (see\tld\cite{Mecca2009, Mecca2011TR,Marnette2010} for details on execution times).

As an alternative, it is possible to compute the target instance by using the internal engine that we detail next.

\subsection{Chase Engine} \label{sec:engine}

For user convenience, an internal engine chases the source to target dependencies produced by the rewriting algorithms. The output is the same of the executable scripts and the performance are acceptable for user interaction with instances up to a few thousands tuples.
The input instance can be defined with the DataSource menu in the system toolbar.

\begin{figure}[htb]
\removespace
\begin{center}
\includegraphics[width=\columnwidth]{images/instance.png}
\removespace
\caption{\small Screenshot of the Instance Window.} \label{fig:instance}
\end{center}
\removelargespace
\end{figure}

The target instance generated by the engine can be observed in the \quotes{Instances Window}, as shown in Figure\tld\ref{fig:instance}. Notice that the system let the user compare the canonical universal solution and the core solution. Moreover, a right click on the right panel reveals some internal technical information that can be useful for debug. For instance, the provenance metadata reports for each record from which s-t tgd it has been created.
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Advanced Features} \label{sec:advanced}

The following features highlight why the {\spicypp} system is a very sophisticated tool. Many of the advanced features can be enabled and disabled from the {\em Configuration} panel, which can be accessed with a right click on the Scenarios panel.

A key contribution of data exchange research is the formalization of the notion of \textit{core}\tld\cite{Fagin2005b}, which is identified as an \quotes{optimal} solution. 
The {\spicypp} system contains an algorithm to rewrite s-t tgds in order to obtain core solutions with executable scripts. This core computation approach allows a very efficient execution that scales well to large databases. We refer the reader to\tld\cite{Mecca2009, Mecca2011TR} for details. By default, the core rewriting is selected in the Configuration panel.

Core-oriented rewriting algorithms have been extended to handle a very large class of mapping scenarios including target functional dependencies, i.e., target egds in data exchange terminology. This means that {\spicypp} generates solution that satisfy the target egds by using source to target dependencies only (and therefore, transformations that can be materialized with common executable languages). See\tld\cite{Marnette2010} for details.
By default, the egd rewriting is deselected in the Configuration panel.

A crucial technical feature of {\spicypp} is the management of the Skolem values, i.e., the way the system choose a value for a labeled null in the solution. 
By default, in the internal engine Skolem values are materialized as integers in the solution, this can be changed selecting \quotes{Use Skolem Strings}  in the Configuration panel.
In the SQL executable scripts, by default Skolem values are materialized as integers or string in the solution, depending from the target datatype of the element; this can be changed to integers selecting \quotes{Skolem Table} in the \quotes{Skolem Table Strategy} menu, or it can be changed to string selecting selecting \quotes{No Skolem Table}. The \quotes{Use Hash Text} can improve the execution time performance of the SQL scripts, but does not guarantee that the solution is the core.




%\subsection*{Acknowledgments}
%\setlength{\baselineskip}{0.9\baselineskip}

%\begin{small}

\bibliographystyle{abbrv}

\bibliography{./dataIntegration}

%\end{small}

\end{document}